//
//  CCToken.m
//  Autogenerated by plank
//
//  DO NOT EDIT - EDITS WILL BE OVERWRITTEN
//  @generated
//

#import "CCToken.h"

struct CCTokenDirtyProperties {
    unsigned int CCTokenDirtyPropertyAccessToken:1;
    unsigned int CCTokenDirtyPropertyExpiresIn:1;
    unsigned int CCTokenDirtyPropertyRefreshToken:1;
    unsigned int CCTokenDirtyPropertyTokenType:1;
};

@interface CCToken ()
@property (nonatomic, assign, readwrite) struct CCTokenDirtyProperties tokenDirtyProperties;
@end

@interface CCTokenBuilder ()
@property (nonatomic, assign, readwrite) struct CCTokenDirtyProperties tokenDirtyProperties;
@end

@implementation CCToken
+ (NSString *)className
{
    return @"CCToken";
}
+ (NSString *)polymorphicTypeIdentifier
{
    return @"token";
}
+ (instancetype)modelObjectWithDictionary:(NSDictionary *)dictionary
{
    return [[self alloc] initWithModelDictionary:dictionary];
}
- (instancetype)init
{
    return [self initWithModelDictionary:@{}];
}
- (instancetype)initWithModelDictionary:(NS_VALID_UNTIL_END_OF_SCOPE NSDictionary *)modelDictionary
{
    NSParameterAssert(modelDictionary);
    if (!modelDictionary) {
        return self;
    }
    if (!(self = [super init])) {
        return self;
    }
        {
            __unsafe_unretained id value = modelDictionary[@"access_token"]; // Collection will retain.
            if (value != nil) {
                if (value != (id)kCFNull) {
                    self->_accessToken = [value copy];
                }
                self->_tokenDirtyProperties.CCTokenDirtyPropertyAccessToken = 1;
            }
        }
        {
            __unsafe_unretained id value = modelDictionary[@"expires_in"]; // Collection will retain.
            if (value != nil) {
                if (value != (id)kCFNull) {
                    self->_expiresIn = [value integerValue];
                }
                self->_tokenDirtyProperties.CCTokenDirtyPropertyExpiresIn = 1;
            }
        }
        {
            __unsafe_unretained id value = modelDictionary[@"refresh_token"]; // Collection will retain.
            if (value != nil) {
                if (value != (id)kCFNull) {
                    self->_refreshToken = [value copy];
                }
                self->_tokenDirtyProperties.CCTokenDirtyPropertyRefreshToken = 1;
            }
        }
        {
            __unsafe_unretained id value = modelDictionary[@"token_type"]; // Collection will retain.
            if (value != nil) {
                if (value != (id)kCFNull) {
                    self->_tokenType = [value copy];
                }
                self->_tokenDirtyProperties.CCTokenDirtyPropertyTokenType = 1;
            }
        }
    if ([self class] == [CCToken class]) {
        [[NSNotificationCenter defaultCenter] postNotificationName:kPlankDidInitializeNotification object:self userInfo:@{ kPlankInitTypeKey : @(PlankModelInitTypeDefault) }];
    }
    return self;
}
- (instancetype)initWithBuilder:(CCTokenBuilder *)builder
{
    NSParameterAssert(builder);
    return [self initWithBuilder:builder initType:PlankModelInitTypeDefault];
}
- (instancetype)initWithBuilder:(CCTokenBuilder *)builder initType:(PlankModelInitType)initType
{
    NSParameterAssert(builder);
    if (!(self = [super init])) {
        return self;
    }
    _accessToken = builder.accessToken;
    _expiresIn = builder.expiresIn;
    _refreshToken = builder.refreshToken;
    _tokenType = builder.tokenType;
    _tokenDirtyProperties = builder.tokenDirtyProperties;
    if ([self class] == [CCToken class]) {
        [[NSNotificationCenter defaultCenter] postNotificationName:kPlankDidInitializeNotification object:self userInfo:@{ kPlankInitTypeKey : @(initType) }];
    }
    return self;
}
- (NSString *)debugDescription
{
    NSArray<NSString *> *parentDebugDescription = [[super debugDescription] componentsSeparatedByString:@"\n"];
    NSMutableArray *descriptionFields = [NSMutableArray arrayWithCapacity:4];
    [descriptionFields addObject:parentDebugDescription];
    struct CCTokenDirtyProperties props = _tokenDirtyProperties;
    if (props.CCTokenDirtyPropertyAccessToken) {
        [descriptionFields addObject:[@"_accessToken = " stringByAppendingFormat:@"%@", _accessToken]];
    }
    if (props.CCTokenDirtyPropertyExpiresIn) {
        [descriptionFields addObject:[@"_expiresIn = " stringByAppendingFormat:@"%@", @(_expiresIn)]];
    }
    if (props.CCTokenDirtyPropertyRefreshToken) {
        [descriptionFields addObject:[@"_refreshToken = " stringByAppendingFormat:@"%@", _refreshToken]];
    }
    if (props.CCTokenDirtyPropertyTokenType) {
        [descriptionFields addObject:[@"_tokenType = " stringByAppendingFormat:@"%@", _tokenType]];
    }
    return [NSString stringWithFormat:@"CCToken = {\n%@\n}", debugDescriptionForFields(descriptionFields)];
}
- (instancetype)copyWithBlock:(PLANK_NOESCAPE void (^)(CCTokenBuilder *builder))block
{
    NSParameterAssert(block);
    CCTokenBuilder *builder = [[CCTokenBuilder alloc] initWithModel:self];
    block(builder);
    return [builder build];
}
- (BOOL)isEqual:(id)anObject
{
    if (self == anObject) {
        return YES;
    }
    if ([anObject isKindOfClass:[CCToken class]] == NO) {
        return NO;
    }
    return [self isEqualToToken:anObject];
}
- (BOOL)isEqualToToken:(CCToken *)anObject
{
    return (
        (anObject != nil) &&
        (_expiresIn == anObject.expiresIn) &&
        (_accessToken == anObject.accessToken || [_accessToken isEqualToString:anObject.accessToken]) &&
        (_refreshToken == anObject.refreshToken || [_refreshToken isEqualToString:anObject.refreshToken]) &&
        (_tokenType == anObject.tokenType || [_tokenType isEqualToString:anObject.tokenType])
    );
}
- (NSUInteger)hash
{
    NSUInteger subhashes[] = {
        17,
        [_accessToken hash],
        (NSUInteger)_expiresIn,
        [_refreshToken hash],
        [_tokenType hash]
    };
    return PINIntegerArrayHash(subhashes, sizeof(subhashes) / sizeof(subhashes[0]));
}
- (instancetype)mergeWithModel:(CCToken *)modelObject
{
    return [self mergeWithModel:modelObject initType:PlankModelInitTypeFromMerge];
}
- (instancetype)mergeWithModel:(CCToken *)modelObject initType:(PlankModelInitType)initType
{
    NSParameterAssert(modelObject);
    CCTokenBuilder *builder = [[CCTokenBuilder alloc] initWithModel:self];
    [builder mergeWithModel:modelObject];
    return [[CCToken alloc] initWithBuilder:builder initType:initType];
}
- (NSDictionary *)dictionaryObjectRepresentation
{
    NSMutableDictionary *dict = [[NSMutableDictionary alloc] initWithCapacity:4];
    if (_tokenDirtyProperties.CCTokenDirtyPropertyAccessToken) {
        if (_accessToken != (id)kCFNull) {
            [dict setObject:_accessToken forKey:@"access_token"];
        } else {
            [dict setObject:[NSNull null] forKey:@"access_token"];
        }
    }
    if (_tokenDirtyProperties.CCTokenDirtyPropertyExpiresIn) {
        [dict setObject:@(_expiresIn) forKey: @"expires_in"];
    }
    if (_tokenDirtyProperties.CCTokenDirtyPropertyRefreshToken) {
        if (_refreshToken != (id)kCFNull) {
            [dict setObject:_refreshToken forKey:@"refresh_token"];
        } else {
            [dict setObject:[NSNull null] forKey:@"refresh_token"];
        }
    }
    if (_tokenDirtyProperties.CCTokenDirtyPropertyTokenType) {
        if (_tokenType != (id)kCFNull) {
            [dict setObject:_tokenType forKey:@"token_type"];
        } else {
            [dict setObject:[NSNull null] forKey:@"token_type"];
        }
    }
    return dict;
}
#pragma mark - NSCopying
- (id)copyWithZone:(NSZone *)zone
{
    return self;
}
#pragma mark - NSSecureCoding
+ (BOOL)supportsSecureCoding
{
    return YES;
}
- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    if (!(self = [super init])) {
        return self;
    }
    _accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"access_token"];
    _expiresIn = [aDecoder decodeIntegerForKey:@"expires_in"];
    _refreshToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"refresh_token"];
    _tokenType = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"token_type"];
    _tokenDirtyProperties.CCTokenDirtyPropertyAccessToken = [aDecoder decodeIntForKey:@"access_token_dirty_property"] & 0x1;
    _tokenDirtyProperties.CCTokenDirtyPropertyExpiresIn = [aDecoder decodeIntForKey:@"expires_in_dirty_property"] & 0x1;
    _tokenDirtyProperties.CCTokenDirtyPropertyRefreshToken = [aDecoder decodeIntForKey:@"refresh_token_dirty_property"] & 0x1;
    _tokenDirtyProperties.CCTokenDirtyPropertyTokenType = [aDecoder decodeIntForKey:@"token_type_dirty_property"] & 0x1;
    if ([self class] == [CCToken class]) {
        [[NSNotificationCenter defaultCenter] postNotificationName:kPlankDidInitializeNotification object:self userInfo:@{ kPlankInitTypeKey : @(PlankModelInitTypeDefault) }];
    }
    return self;
}
- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.accessToken forKey:@"access_token"];
    [aCoder encodeInteger:self.expiresIn forKey:@"expires_in"];
    [aCoder encodeObject:self.refreshToken forKey:@"refresh_token"];
    [aCoder encodeObject:self.tokenType forKey:@"token_type"];
    [aCoder encodeInt:_tokenDirtyProperties.CCTokenDirtyPropertyAccessToken forKey:@"access_token_dirty_property"];
    [aCoder encodeInt:_tokenDirtyProperties.CCTokenDirtyPropertyExpiresIn forKey:@"expires_in_dirty_property"];
    [aCoder encodeInt:_tokenDirtyProperties.CCTokenDirtyPropertyRefreshToken forKey:@"refresh_token_dirty_property"];
    [aCoder encodeInt:_tokenDirtyProperties.CCTokenDirtyPropertyTokenType forKey:@"token_type_dirty_property"];
}
@end

@implementation CCTokenBuilder
- (instancetype)initWithModel:(CCToken *)modelObject
{
    NSParameterAssert(modelObject);
    if (!(self = [super init])) {
        return self;
    }
    struct CCTokenDirtyProperties tokenDirtyProperties = modelObject.tokenDirtyProperties;
    if (tokenDirtyProperties.CCTokenDirtyPropertyAccessToken) {
        _accessToken = modelObject.accessToken;
    }
    if (tokenDirtyProperties.CCTokenDirtyPropertyExpiresIn) {
        _expiresIn = modelObject.expiresIn;
    }
    if (tokenDirtyProperties.CCTokenDirtyPropertyRefreshToken) {
        _refreshToken = modelObject.refreshToken;
    }
    if (tokenDirtyProperties.CCTokenDirtyPropertyTokenType) {
        _tokenType = modelObject.tokenType;
    }
    _tokenDirtyProperties = tokenDirtyProperties;
    return self;
}
- (CCToken *)build
{
    return [[CCToken alloc] initWithBuilder:self];
}
- (void)mergeWithModel:(CCToken *)modelObject
{
    NSParameterAssert(modelObject);
    CCTokenBuilder *builder = self;
    if (modelObject.tokenDirtyProperties.CCTokenDirtyPropertyAccessToken) {
        builder.accessToken = modelObject.accessToken;
    }
    if (modelObject.tokenDirtyProperties.CCTokenDirtyPropertyExpiresIn) {
        builder.expiresIn = modelObject.expiresIn;
    }
    if (modelObject.tokenDirtyProperties.CCTokenDirtyPropertyRefreshToken) {
        builder.refreshToken = modelObject.refreshToken;
    }
    if (modelObject.tokenDirtyProperties.CCTokenDirtyPropertyTokenType) {
        builder.tokenType = modelObject.tokenType;
    }
}
- (void)setAccessToken:(NSString *)accessToken
{
    _accessToken = [accessToken copy];
    _tokenDirtyProperties.CCTokenDirtyPropertyAccessToken = 1;
}
- (void)setExpiresIn:(NSInteger)expiresIn
{
    _expiresIn = expiresIn;
    _tokenDirtyProperties.CCTokenDirtyPropertyExpiresIn = 1;
}
- (void)setRefreshToken:(NSString *)refreshToken
{
    _refreshToken = [refreshToken copy];
    _tokenDirtyProperties.CCTokenDirtyPropertyRefreshToken = 1;
}
- (void)setTokenType:(NSString *)tokenType
{
    _tokenType = [tokenType copy];
    _tokenDirtyProperties.CCTokenDirtyPropertyTokenType = 1;
}
@end
